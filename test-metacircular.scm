; Unit tests for the metacircular evaluator

(use test)
(load "metacircular.scm")

(define (test-eval-apply eval-fn)
  (let ((env the-empty-environment))
    (begin
      (test "Self-evaluating: numeric" 1 (eval-fn 1 env))
      (test "Self-evaluating: string" "hello, world!" (eval-fn "hello, world!" env))
      (test "Quoted: 'foo" ''foo (eval-fn '''foo env))
      (test "Quoted: 'bar" ''bar (eval-fn '''bar env))
      (let* ((test-env (extend-environment '(a b) '(1 2) the-empty-environment))
             (test-frame (first-frame test-env)))
        (add-binding-to-frame! 'c 3 test-frame)
        (add-binding-to-frame! 'f (make-procedure '(input) '(if input 1 2) test-env) (first-frame (extend-environment '() '() the-empty-environment)))
        (test "add-binding-to-frame!" '() (begin test-frame)))
      (let* ((test-env (extend-environment '() '() the-empty-environment))
             (dummy (define-variable! 'foo 42 test-env))
             (result-foo (lookup-variable-value 'foo test-env))
             (dummy (define-variable! 'bar 24 test-env))
             (result-bar (lookup-variable-value 'bar test-env)))
        (test "set/lookup variable foo" 42 result-foo)
        (test "set/lookup variable bar" 24 result-bar))
      (let* ((test-env (extend-environment '() '() the-empty-environment)))
        (define-variable! 'foobar 42 test-env)
        (test "Define variable foobar" 42 (lookup-variable-value 'foobar test-env))
        (test "Eval variable foobar" 42 (eval-fn 'foobar test-env))
        (eval-fn '(set! foobar 24) test-env)
        (test "Assign variable foobar" 24 (eval-fn 'foobar test-env))
        (test "Sequence evaluation"
              42
              (eval-fn '(begin (define xx 42) xx) test-env)))
      (test "If with true predicate" 42 (eval-fn '(if true 42 24) env))
      (test "If with false predicate" 24 (eval-fn '(if false 42 24) env))
      (test "cond-clauses" '((true 1) (false 2) (else -1)) (cond-clauses '(cond (true 1) (false 2) (else -1))))
      (test "cond->if: null clauses" 'false (cond->if '(cond)))
      (test "cond: null clauses" #f (eval-fn '(cond) env))
      (test "cond: first predicate" 1 (eval-fn '(cond (true 1) (false 2) (else -1)) env))
      (test "cond: second predicate" 2 (eval-fn '(cond (false 1) (true 2) (else -1)) env))
      (test "cond: fallback" -1 (eval-fn '(cond (false 1) (false 2) (else -1)) env))
      (let ((test-env (extend-environment '() '() the-empty-environment))
            (test-func-quoted '(define (test-func input) (if input 1 2)))
            (test-lambda-quoted '(lambda (input) (if input 1 2))))
        (test "lambda-parameters" '(input) (lambda-parameters test-lambda-quoted))
        (test "lambda-body" '((if input 1 2)) (lambda-body test-lambda-quoted))
        (test "make-procedure" '(procedure (input) ((if input 1 2)) ((())))
                               (make-procedure (lambda-parameters test-lambda-quoted)
                                               (lambda-body test-lambda-quoted)
                                               test-env))
        (test "lambda" '(procedure (input) ((if input 1 2)) ((()))) (eval-fn '(lambda (input) (if input 1 2)) test-env))
        (test "definition-variable" 'test-func (definition-variable test-func-quoted))
        (test "definition-value" '(lambda (input) (if input 1 2)) (definition-value test-func-quoted))
        (display (micro-eval '(lambda (input) (if input 1 2)) test-env))(newline)
        (define-variable! 'blah (micro-eval '(lambda (input) (if input 1 2)) test-env) test-env)
        ;(display (cdar test-env))(newline)
        ;(eval-fn test-func-quoted test-env)
        ;(test "Function lookup" '(procedure (input) (if input 1 2) ((()))) (lookup-variable-value 'test-func test-env))
        )
      )))



(test-eval-apply micro-eval)

